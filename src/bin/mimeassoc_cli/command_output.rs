use serde::Serialize;
use std::path::PathBuf;

use mimeassoc::*;

/// Container for output generated by cli commands
pub enum CommandOutput {
    MimeTypes(Vec<MimeTypesCommandOutput>),
    MimeType(Vec<MimeTypeCommandOutput>),
    Applications(Vec<ApplicationCommandOutput>),
    Application(ApplicationCommandOutput),
    Set(SetDefaultHandlerCommandOutput),
    Reset(ResetDefaultHandlerCommandOutput),
    Configuration(ConfigurationCommandOutput),
}

#[derive(Serialize)]
pub struct MimeTypesCommandOutput {
    pub mime_type: MimeType,
    pub mime_info: Option<MimeTypeInfo>,
}

#[derive(Serialize)]
pub struct MimeTypeCommandHandlerInfo {
    pub desktop_entry: DesktopEntryId,
    pub is_default_handler: bool,
}

#[derive(Serialize)]
pub struct MimeTypeCommandOutput {
    pub mime_type: MimeType,
    pub mime_info: Option<MimeTypeInfo>,
    pub handler_info: Vec<MimeTypeCommandHandlerInfo>,
}

#[derive(Serialize)]
pub struct MimeInfo {
    pub mime_type: MimeType,
    pub is_default_handler: bool,
}

#[derive(Serialize)]
pub struct ApplicationCommandOutput {
    pub desktop_entry: Option<DesktopEntryId>,
    pub mime_info: Vec<MimeInfo>,
}

#[derive(Serialize)]
pub struct SetDefaultHandlerCommandOutput {
    pub desktop_entry: DesktopEntryId,
    pub mime_types: Vec<MimeType>,
}

#[derive(Serialize)]
pub struct ResetDefaultHandlerCommandOutput {
    pub reset_mime_types: Vec<MimeType>,
}

#[derive(Serialize)]
pub struct ConfigurationCommandOutput {
    pub mime_association_scope_paths: Vec<PathBuf>,
    pub desktop_entry_scope_paths: Vec<PathBuf>,
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// Trait for handler types for processing CommandOutput
pub trait CommandOutputConsumer {
    fn process(&self, command_output: &CommandOutput) -> anyhow::Result<()>;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// The DefaultCommandOutputConsumer is human-readable text
#[derive(Default)]
pub struct DefaultCommandOutputConsumer {}

impl CommandOutputConsumer for DefaultCommandOutputConsumer {
    fn process(&self, command_output: &CommandOutput) -> anyhow::Result<()> {
        match command_output {
            CommandOutput::MimeTypes(output) => Self::display_mime_types_command_output(output),
            CommandOutput::MimeType(output) => Self::display_mime_type_command_output(output),
            CommandOutput::Applications(output) => {
                Self::display_applications_command_output(output)
            }
            CommandOutput::Application(output) => Self::display_application_command_output(output),
            CommandOutput::Set(output) => Self::display_set_default_handler_command_output(output),
            CommandOutput::Reset(output) => {
                Self::display_reset_default_handler_command_output(output)
            }
            CommandOutput::Configuration(output) => {
                Self::display_configuration_command_output(output)
            }
        }
        Ok(())
    }
}

impl DefaultCommandOutputConsumer {
    fn display_mime_info(mime_info: &MimeTypeInfo) {
        if mime_info.comment().is_none() && mime_info.extensions().is_empty() {
            return;
        }

        print!(" [");

        if let Some(comment) = mime_info.comment() {
            print!("comment: \"{}\"", comment);
        }
        let extensions = mime_info.extensions();
        if !extensions.is_empty() {
            if mime_info.comment().is_some() {
                print!(", ");
            }

            let extensions = extensions.join(", ");
            print!("extensions: \"{}\"", extensions);
        }

        print!("]");
    }

    fn display_mime_types_command_output(output: &[MimeTypesCommandOutput]) {
        for mime_type in output.iter() {
            print!("{}", mime_type.mime_type);
            if let Some(mime_info) = &mime_type.mime_info {
                Self::display_mime_info(mime_info);
            }
            println!();
        }
    }

    fn display_mime_type_command_output(output: &[MimeTypeCommandOutput]) {
        for entry in output.iter() {
            print!("{}:", entry.mime_type);
            if let Some(mime_info) = &entry.mime_info {
                Self::display_mime_info(mime_info);
            }
            println!();

            for handler in entry.handler_info.iter() {
                if handler.is_default_handler {
                    println!("\t*{}", handler.desktop_entry);
                } else {
                    println!("\t {}", handler.desktop_entry);
                }
            }
            println!();
        }
    }

    fn display_applications_command_output(output: &[ApplicationCommandOutput]) {
        for info in output.iter() {
            Self::display_application_command_output(info);
            println!("\n");
        }
    }

    fn display_application_command_output(output: &ApplicationCommandOutput) {
        if let Some(desktop_entry) = &output.desktop_entry {
            println!("{}", desktop_entry);
            for mime_info in output.mime_info.iter() {
                if mime_info.is_default_handler {
                    println!("\t*{}", mime_info.mime_type);
                } else {
                    println!("\t {}", mime_info.mime_type);
                }
            }
        } else {
            println!("No matching application found.");
        }
    }

    fn display_set_default_handler_command_output(output: &SetDefaultHandlerCommandOutput) {
        if output.mime_types.is_empty() {
            println!("No mime types were assigned to {}", output.desktop_entry);
        } else {
            println!("Assigned {} to:", output.desktop_entry);
            for mime_type in output.mime_types.iter() {
                println!("\t{}", mime_type)
            }
        }
    }

    fn display_reset_default_handler_command_output(output: &ResetDefaultHandlerCommandOutput) {
        if output.reset_mime_types.is_empty() {
            println!("No mimetypes were reset.");
        } else {
            println!(
                "Reset {}",
                output
                    .reset_mime_types
                    .iter()
                    .map(|m| m.to_string())
                    .collect::<Vec<_>>()
                    .join(", ")
            );
        }
    }

    fn display_configuration_command_output(output: &ConfigurationCommandOutput) {
        println!("mimeapps.lists:");
        for path in output.mime_association_scope_paths.iter() {
            if let Some(path) = path.to_str() {
                println!("\t{}", path);
            }
        }
        println!("\nDesktop entry dirs:");
        for path in output.desktop_entry_scope_paths.iter() {
            if let Some(path) = path.to_str() {
                println!("\t{}", path);
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#[derive(Default)]
pub struct JsonCommandOutputConsumer {}

impl CommandOutputConsumer for JsonCommandOutputConsumer {
    fn process(&self, command_output: &CommandOutput) -> anyhow::Result<()> {
        let json_string = match command_output {
            CommandOutput::MimeTypes(output) => serde_json::to_string_pretty(output),
            CommandOutput::MimeType(output) => serde_json::to_string_pretty(output),
            CommandOutput::Applications(output) => serde_json::to_string_pretty(output),
            CommandOutput::Application(output) => serde_json::to_string_pretty(output),
            CommandOutput::Set(output) => serde_json::to_string_pretty(output),
            CommandOutput::Reset(output) => serde_json::to_string_pretty(output),
            CommandOutput::Configuration(output) => serde_json::to_string_pretty(output),
        }?;

        println!("{}", json_string);

        Ok(())
    }
}
