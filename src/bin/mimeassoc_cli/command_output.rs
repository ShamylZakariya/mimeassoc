use std::path::PathBuf;

use mimeassoc::{desktop_entry::DesktopEntryId, mime_type::*};

/// Container for output generated by cli commands
pub enum CommandOutput {
    MimeTypes(Vec<MimeTypesCommandOutput>),
    MimeType(Vec<MimeTypeCommandOutput>),
    Applications(Vec<ApplicationCommandOutput>),
    Application(ApplicationCommandOutput),
    Set(SetDefaultHandlerCommandOutput),
    Reset(ResetDefaultHandlerCommandOutput),
    Configuration(ConfigurationCommandOutput),
}

pub struct MimeTypesCommandOutput {
    pub mime_type: MimeType,
}

pub struct MimeTypeCommandHandlerInfo {
    pub desktop_entry: DesktopEntryId,
    pub is_default_handler: bool,
}
pub struct MimeTypeCommandOutput {
    pub mime_type: MimeType,
    pub handler_info: Vec<MimeTypeCommandHandlerInfo>,
}

pub struct MimeInfo {
    pub mime_type: MimeType,
    pub is_default_handler: bool,
}

pub struct ApplicationCommandOutput {
    pub desktop_entry: DesktopEntryId,
    pub mime_info: Vec<MimeInfo>,
}

pub struct SetDefaultHandlerCommandOutput {
    pub desktop_entry: DesktopEntryId,
    pub mime_types: Vec<MimeType>,
}

pub struct ResetDefaultHandlerCommandOutput {
    pub mime_types: Vec<MimeType>,
}

pub struct ConfigurationCommandOutput {
    pub mime_association_scope_paths: Vec<PathBuf>,
    pub desktop_entry_scope_paths: Vec<PathBuf>,
}

/// Trait for handler types for processing CommandOutput
pub trait CommandOutputConsumer {
    fn process(&self, command_output: &CommandOutput) -> anyhow::Result<()>;
}

/// The DefaultCommandOutputConsumer is human-readable text
pub struct DefaultCommandOutputConsumer {}

impl CommandOutputConsumer for DefaultCommandOutputConsumer {
    fn process(&self, command_output: &CommandOutput) -> anyhow::Result<()> {
        match command_output {
            CommandOutput::MimeTypes(output) => Self::display_mime_types_command_output(output),
            CommandOutput::MimeType(output) => Self::display_mime_type_command_output(output),
            CommandOutput::Applications(output) => {
                Self::display_applications_command_output(output)
            }
            CommandOutput::Application(output) => Self::display_application_command_output(output),
            CommandOutput::Set(output) => Self::display_set_default_handler_command_output(output),
            CommandOutput::Reset(output) => {
                Self::display_reset_default_handler_command_output(output)
            }
            CommandOutput::Configuration(output) => {
                Self::display_configuration_command_output(output)
            }
        }
        Ok(())
    }
}

impl DefaultCommandOutputConsumer {
    fn display_mime_types_command_output(output: &[MimeTypesCommandOutput]) {
        for mime_type in output.iter() {
            println!("{}", mime_type.mime_type);
        }
    }

    fn display_mime_type_command_output(output: &[MimeTypeCommandOutput]) {
        for entry in output.iter() {
            println!("{}:", entry.mime_type);
            for handler in entry.handler_info.iter() {
                if handler.is_default_handler {
                    println!("\t*{}", handler.desktop_entry);
                } else {
                    println!("\t {}", handler.desktop_entry);
                }
            }
            println!();
        }
    }

    fn display_applications_command_output(output: &[ApplicationCommandOutput]) {
        for info in output.iter() {
            Self::display_application_command_output(info);
            println!("\n");
        }
    }

    fn display_application_command_output(output: &ApplicationCommandOutput) {
        println!("{}", output.desktop_entry);
        for mime_info in output.mime_info.iter() {
            if mime_info.is_default_handler {
                println!("\t*{}", mime_info.mime_type);
            } else {
                println!("\t {}", mime_info.mime_type);
            }
        }
    }

    fn display_set_default_handler_command_output(output: &SetDefaultHandlerCommandOutput) {
        if output.mime_types.is_empty() {
            println!("No mime types were assigned to {}", output.desktop_entry);
        } else {
            println!("Assigned {} to:", output.desktop_entry);
            for mime_type in output.mime_types.iter() {
                println!("\t{}", mime_type)
            }
        }
    }

    fn display_reset_default_handler_command_output(output: &ResetDefaultHandlerCommandOutput) {
        if output.mime_types.is_empty() {
            println!("No mimetypes were reset.");
        } else {
            println!(
                "Reset {}",
                output
                    .mime_types
                    .iter()
                    .map(|m| m.to_string())
                    .collect::<Vec<_>>()
                    .join(", ")
            );
        }
    }

    fn display_configuration_command_output(output: &ConfigurationCommandOutput) {
        println!("mimeapps.lists:");
        for path in output.mime_association_scope_paths.iter() {
            if let Some(path) = path.to_str() {
                println!("\t{}", path);
            }
        }
        println!("\nDesktop entry dirs:");
        for path in output.desktop_entry_scope_paths.iter() {
            if let Some(path) = path.to_str() {
                println!("\t{}", path);
            }
        }
    }
}
